\chapter{Lyhimmät polut}

Monissa verkkoihin liittyvissä ongelmissa on kysymys siitä,
että haluamme löytää \emph{lyhimmän polun} verkon solmusta toiseen.
Esimerkiksi voimme haluta selvittää,
mikä on nopein reitti kahden katuosoitteen välillä
tai mikä on halvin tapa lentää kaupungista toiseen.
Näissä ja muissa sovelluksissa on tärkeää,
että löydämme lyhimmän polun tehokkaasti.

Olemme käyttäneet aiemmin leveyshakua lyhimpien
polkujen etsimiseen.
Tämä onkin hyvä ratkaisu, kun haluamme löytää polut,
joiden kaarten määrä on pienin.
Tässä luvussa keskitymme kuitenkin vaikeampaan
tilanteeseen, jossa verkko on \emph{painotettu}
ja haluamme löytää polut,
joissa painojen summa on pienin.
Tällöin emme voi enää käyttää leveyshakua vaan
tarvitsemme kehittyneempiä menetelmiä.

Lyhimpien polkujen etsimiseen painotetussa verkossa
on monia algoritmeja, joilla on erilaisia ominaisuuksia.
Tässä luvussa käymme läpi ensin Bellman–Fordin algoritmin ja
Dijkstran algoritmin,
jotka etsivät lyhimmät polut annetusta lähtösolmusta
kaikkiin verkon solmuihin.
Tämän jälkeen tutustumme Floyd–Warshallin algoritmiin,
joka etsii samanaikaisesti lyhimmät polut kaikkien
verkon solmujen välillä.

\section{Lyhimmät polut lähtösolmusta}

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.7,label distance=0mm]
\small
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$0$};
\node[color=red] at (2,0.75) {$6$};
\node[color=red] at (2,-2.75) {$2$};
\node[color=red] at (4,0.75) {$11$};
\node[color=red] at (4,-2.75) {$9$};
\end{tikzpicture}
\end{center}
\caption{Lyhimpien polkujen pituudet solmusta $1$ alkaen.}
\label{fig:lypola}
\end{figure}

Tavallisin tilanne käytännön verkko-ongelmissa on,
että haluamme löytää lyhimmän polun verkon solmusta toiseen.
Yksittäisen lyhimmän polun etsiminen vaatii usein kuitenkin,
että etsimme sitä ennen muitakin lyhimpiä polkuja.
Niinpä keskitymme alusta asti yleisempään ongelmaan,
jossa olemme valinneet jonkin solmun lähtösolmuksi
ja haluamme määrittää \emph{jokaiselle} verkon solmulle,
kuinka pitkä on lyhin polku lähtösol\-musta solmuun
eli mikä on solmun etäisyys lähtösolmusta.

Kuvassa \ref{fig:lypola} on esimerkkinä verkko,
jossa lähtösolmuna on solmu $1$ ja jokaisen solmun
viereen on merkitty sen etäisyys.
Esimerkiksi solmun $5$ etäisyys on $9$,
koska lyhin polku solmusta $1$ solmuun $5$ on
$1 \rightarrow 3 \rightarrow 5$, jonka pituus on $2+7=9$.
Käytämme tätä verkkoa esimerkkinä, kun tutustumme
seuraavaksi kahteen algoritmiin lyhimpien polkujen etsimiseen.

\subsection{Bellman–Fordin algoritmi}

Bellman–Fordin algoritmi etsii lyhimmät polut
annetusta lähtösolmusta kaikkiin verkon solmuihin.
Algoritmi muodostaa taulukon, joka kertoo jokaiselle
verkon solmulle sen etäisyyden lähtösolmusta.
Algoritmi toimii missä tahansa verkossa,
kunhan verkossa ei ole negatiivista sykliä eli sykliä,
jonka painojen summa on negatiivinen.

Bellman–Fordin algoritmi pitää yllä \emph{arvioita}
solmujen etäisyyksistä niin,
että aluksi etäisyys lähtösolmuun on 0 ja etäisyys
kaikkiin muihin solmuihin on ääretön.
Tämän jälkeen algoritmi alkaa parantaa etäisyyksiä
etsimällä verkosta kaaria, joiden kautta kulkeminen
lyhentää polkuja.
Jokaisella askeleella algoritmi etsii kaaren $a \rightarrow b$,
jolle pätee, että pääsemme solmuun $b$ aiempaa lyhempää polkua
kulkemalla kaarella solmusta $a$.
Kun mitään etäisyysarviota ei voi enää parantaa,
algoritmi päättyy ja kaikki etäisyydet vastaavat
todellisia lyhimpien polkujen pituuksia.

\begin{figure}[ht]
\center
\begin{center}
\begin{tikzpicture}[scale=0.65,label distance=-1.5mm]
\footnotesize
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$#2$};
\node[color=red] at (2,0.75) {$#3$};
\node[color=red] at (2,-2.75) {$#4$};
\node[color=red] at (4,0.75) {$#5$};
\node[color=red] at (4,-2.75) {$#6$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}{0}{\infty}{\infty}{\infty}{\infty}
\end{scope}
\begin{scope}[xshift=6.5cm]
\verkko{2}{0}{8}{\infty}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (2);
\end{scope}
\begin{scope}[xshift=13cm]
\verkko{3}{0}{8}{2}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (3);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\verkko{4}{0}{8}{2}{13}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\verkko{5}{0}{6}{2}{13}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (2);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\verkko{6}{0}{6}{2}{13}{9}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (5);
\end{scope}
\begin{scope}[yshift=-11cm]
\verkko{7}{0}{6}{2}{12}{9}
\path[draw=red,thick,->,line width=1.5pt] (5) -- (4);
\end{scope}
\begin{scope}[yshift=-11cm,xshift=6.5cm]
\verkko{8}{0}{6}{2}{11}{9}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Bellman–Fordin algoritmin toiminnasta.}
\label{fig:belfor}
\end{figure}

Kuva \ref{fig:belfor} näyttää esimerkin Bellman–Fordin algoritmin toiminnasta,
kun lähtösolmuna on solmu $1$.
Jokaisen solmun vieressä on ilmoitettu sen etäisyysarvio:
aluksi etäisyys solmuun 1 on 0 ja etäisyys kaikkiin muihin solmuihin on ääretön.
Jokainen etäisyyden muutos näkyy kuvassa omana vaiheenaan.
Ensin parannamme etäisyyttä solmuun 2
kulkemalla kaarta $1 \rightarrow 2$,
jolloin etäisyydeksi tulee $8$.
Sitten parannamme etäisyyttä solmuun $3$
kulkemalla kaarta $1 \rightarrow 3$,
jolloin solmun uudeksi etäisyydeksi tulee $2$.
Jatkamme samalla tavalla, kunnes emme voi enää parantaa
mitään etäisyyttä ja kaikki etäisyydet
vastaavat lyhimpien polkujen pituuksia.

Bellman–Fordin algoritmi on mukavaa toteuttaa
käyttäen verkon kaarilistaesitystä,
jossa jokaisesta kaaresta on tallennettu alku- ja loppusolmu sekä paino.
Toteutamme algoritmin niin,
että se muodostuu \emph{kierroksista},
joista jokainen käy läpi kaikki verkon kaaret
ja koettaa parantaa etäisyysarvioita niiden avulla.
Kuten pian huomaamme, algoritmia riittää suorittaa $n-1$
kierrosta, minkä jälkeen se on varmasti löytänyt
kaikki lyhimmät polut. Voimme siis toteuttaa algoritmin seuraavasti:

\begin{code}
for i = 1 to n-1
    for kaari in kaaret
        nyky = etaisyys[kaari.loppu]
        uusi = etaisyys[kaari.alku]+kaari.paino
        if uusi < nyky
            etaisyys[kaari.loppu] = uusi
\end{code}

Algoritmi käy jokaisella kierroksella läpi verkon kaaret
ja tutkii kunkin kaaren kohdalla,
mikä on nykyinen etäisyys kaaren kohdesolmuun
sekä mikä on uusi etäisyys, jos kuljemmekin solmuun kaaren kautta.
Jos uusi etäisyys on pienempi, päivitämme
sen solmun etäisyysarvioksi.

Olemme nyt kuvailleet ja toteuttaneet algoritmin,
mutta miten voimme olla varmoja,
että algoritmi löytää kaikissa tilanteissa lyhimmät polut $n-1$ kierroksen kuluessa?
Jotta voimme vastata tähän kysymykseen,
tarvitsemme kaksi havaintoa koskien verkon lyhimpiä polkuja.

Ensimmäinen havainto on, että jos lyhin polku solmusta $s_1$ solmuun $s_k$ on
$s_1 \rightarrow s_2 \rightarrow \dots \rightarrow s_k$,
niin myös lyhin polku solmusta $s_1$ solmuun $s_2$ on $s_1 \rightarrow s_2$,
lyhin polku solmusta $s_1$ solmuun $s_3$ on $s_1 \rightarrow s_2 \rightarrow s_3$, jne.,
eli jokainen polun alkuosa on myös lyhin polku vastaavaan solmuun.
Jos näin ei olisi, voisimme parantaa lyhintä polkua solmusta $s_1$ solmuun $s_k$
parantamalla jotain polun alkuosaa, mikä aiheuttaisi ristiriidan.

Toinen havainto on,
että $n$ solmun verkossa jokainen lyhin polku voi
sisältää enintään $n-1$ kaarta,
kun oletamme, että verkossa ei ole negatiivista sykliä.
Jos polkuun kuuluisi $n$ tai enemmän kaaria,
jokin solmu esiintyisi polulla monta kertaa.
Tämä ei ole kuitenkaan mahdollista,
koska ei olisi järkeä kulkea monta kertaa saman solmun kautta,
kun haluamme saada aikaan lyhimmän polun.

Tarkastellaan nyt, mitä tapahtuu algoritmin kierroksissa.
Ensimmäisen kierroksen jälkeen olemme löytäneet lyhimmät polut,
joissa on enintään yksi kaari.
Toisen kierroksen jälkeen olemme löytäneet lyhimmät polut,
joissa on enintään kaksi kaarta.
Sama jatkuu, kunnes $n-1$ kierroksen jälkeen olemme löytäneet
lyhimmät polut, joissa on enintään $n-1$ kaarta.
Koska missään lyhimmässä polussa ei voi olla enempää kaaria,
olemme löytäneet kaikki lyhimmät polut.
Algoritmin riittää suorittaa siis $n-1$ kierrosta,
joista jokainen käy läpi kaikki verkon kaaret ajassa $O(m)$.
Niinpä algoritmi löytää kaikki lyhimmät polut ajassa $O(nm)$.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\node[draw, circle] (1) at (1,3) {$1$};
\node[draw, circle] (2) at (4,3) {$2$};
\node[draw, circle] (3) at (1,1) {$3$};
\node[draw, circle] (4) at (4,1) {$4$};
\node[draw, circle] (5) at (6,2) {$5$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:1] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:3] {} (3);
\path[draw,thick,<-] (3) -- node[font=\small,label=below:4] {} (4);
\path[draw,thick,->] (2) -- node[font=\small,label=left:$-7$] {} (4);
\path[draw,thick,<-] (2) -- node[font=\small,label=above:2] {} (5);
\path[draw,thick,->] (4) -- node[font=\small,label=below:3] {} (5);

\path[draw,thick,->,red,line width=2pt] (2) -- (4);
\path[draw,thick,->,red,line width=2pt] (4) -- (5);
\path[draw,thick,->,red,line width=2pt] (5) -- (2);

\end{tikzpicture}
\end{center}
\caption{Negatiivinen sykli $2 \rightarrow 4 \rightarrow 5 \rightarrow 2$,
jonka avulla voimme lyhentää polkuja loputtomasti.}
\label{fig:belsyk}
\end{figure}

Mitä tapahtuu sitten, jos verkossa on negatiivinen sykli?
Esimerkiksi kuvan \ref{fig:belsyk} verkossa on negatiivinen sykli
$2 \rightarrow 4 \rightarrow 5 \rightarrow 2$, jonka paino on $-2$.
Tässä tilanteessa Bellman–Fordin algoritmi jää jumiin, koska se pystyy parantamaan
loputtomasti syklin kautta kulkevia polkuja.
Oikeastaan ongelma on siinä, että lyhin polku ei ole mielekäs käsite,
jos polun osana on negatiivinen sykli.
Voimme kuitenkin havaita negatiivisen syklin suorittamalla
algoritmia $n$ kierrosta tavallisen $n-1$ kierroksen sijaan.
Jos jokin etäisyys paranee viimeisellä kierroksella,
olemme löytäneet negatiivisen syklin.

\subsection{Dijkstran algoritmi}

Dijkstran algoritmi on Bellman–Fordin algoritmin tehostettu versio,
jonka toiminta perustuu oletukseen, että verkossa ei ole
negatiivisen painoisia kaaria.
Bellman–Fordin algoritmin tapaan Dijkstran algoritmi pitää
yllä arvioita etäisyyksistä lähtösolmusta muihin solmuihin.
Erona on kuitenkin tapa, miten Dijkstran algoritmi parantaa etäisyyksiä.

Dijkstran algoritmissa verkon solmut kuuluvat kahteen luokkaan:
käsitte\-lemättömiin ja käsiteltyihin.
Aluksi kaikki solmut ovat käsittelemättömiä.
Algoritmi etsii jokaisessa vaiheessa käsittelemättömän solmun,
jonka etäisyys\-arvio on pienin.
Sitten algoritmi käy läpi kaikki solmusta lähtevät kaaret ja
koettaa parantaa etäisyyksiä niiden avulla.
Tämän jälkeen solmu on käsitelty eikä sen etäisyys enää muutu,
eli aina kun olemme käsitelleet solmun,
olemme saaneet selville sen lopullisen etäisyyden.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.65,label distance=-1.5mm]
\footnotesize
\newcommand\verkko[6]{
\node[draw, circle] (1) at (0,-1) {$1$};
\node[draw, circle] (2) at (2,0) {$2$};
\node[draw, circle] (3) at (2,-2) {$3$};
\node[draw, circle] (4) at (4,0) {$4$};
\node[draw, circle] (5) at (4,-2) {$5$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:8] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:2] {} (3);
\path[draw,thick,->] (3) -- node[font=\small,label=right:4] {} (2);
\path[draw,thick,->] (2) -- node[font=\small,label=above:5] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:7] {} (5);
\path[draw,thick,->] (5) -- node[font=\small,label=right:3] {} (4);
\node[color=red] at (0,-0.25) {$#2$};
\node[color=red] at (2,0.75) {$#3$};
\node[color=red] at (2,-2.75) {$#4$};
\node[color=red] at (4,0.75) {$#5$};
\node[color=red] at (4,-2.75) {$#6$};
\node at (2,-3.5) {vaihe #1};
}
\begin{scope}
\verkko{1}{0}{\infty}{\infty}{\infty}{\infty}
\end{scope}
\begin{scope}[xshift=6.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\verkko{2}{0}{8}{2}{\infty}{\infty}
\path[draw=red,thick,->,line width=1.5pt] (1) -- (2);
\path[draw=red,thick,->,line width=1.5pt] (1) -- (3);
\end{scope}
\begin{scope}[xshift=13cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\verkko{3}{0}{6}{2}{\infty}{9}
\path[draw=red,thick,->,line width=1.5pt] (3) -- (2);
\path[draw=red,thick,->,line width=1.5pt] (3) -- (5);
\end{scope}
\begin{scope}[yshift=-5.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\verkko{4}{0}{6}{2}{11}{9}
\path[draw=red,thick,->,line width=1.5pt] (2) -- (4);
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=6.5cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\node[draw, circle, fill=lightgray] (5) at (4,-2) {$5$};
\verkko{5}{0}{6}{2}{11}{9}
\end{scope}
\begin{scope}[yshift=-5.5cm,xshift=13cm]
\node[draw, circle, fill=lightgray] (1) at (0,-1) {$1$};
\node[draw, circle, fill=lightgray] (3) at (2,-2) {$3$};
\node[draw, circle, fill=lightgray] (2) at (2,0) {$2$};
\node[draw, circle, fill=lightgray] (5) at (4,-2) {$5$};
\node[draw, circle, fill=lightgray] (4) at (4,0) {$4$};
\verkko{6}{0}{6}{2}{11}{9}
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Dijkstran algoritmin toiminnasta.}
\label{fig:dijalg}
\end{figure}

Kuva \ref{fig:dijalg} näyttää esimerkin Dijkstran algoritmin
toiminnasta.
Solmun harmaa väri tarkoittaa, että se on käsitelty.
Aluksi valitsemme käsittelyyn solmun 1, koska sen etäisyys 0 on pienin.
Sitten jäljellä ovat solmut 2, 3, 4 ja 5,
joista valitsemme käsittelyyn solmun 3, jonka etäisyys 2 on pienin.
Tämän jälkeen valitsemme käsittelyyn solmun 2,
jonka etäisyys on 6.
Sama jatkuu, kunnes olemme käsitelleet kaikki verkon solmut.

Dijkstran algoritmissa etsimme $n$ kertaa
käsittelemättömän solmun, jonka etäisyysarvio on pienin.
Koska haluamme saada algoritmista tehokkaan,
meidän täytyy pystyä löytämään solmut nopeasti.
Tavallinen tapa toteuttaa Dijkstran algoritmi on käyttää \emph{kekoa},
jonka avulla löydämme joka vaiheessa pienimmän etäisyyden solmun
logaritmisessa ajassa.
Tallennamme kekoon pareja, joissa on solmun etäisyys ja tunnus,
järjestettynä etäisyyden mukaan pienimmästä suurimpaan.
Aluksi keossa on vain lähtösolmua vastaava solmu,
jonka etäisyys on $0$.
Tämän jälkeen haemme joka askeleella keosta solmun,
jonka etäisyys on pienin.
Jos solmu on jo käsitelty, emme tee mitään.
Muuten käymme läpi kaikki solmusta lähtevät kaaret
ja tarkastamme, voimmeko parantaa etäisyyksiä
niiden avulla.
Aina kun voimme parantaa etäisyyttä,
lisäämme uuden etäisyyden kekoon.

Voimme toteuttaa algoritmin seuraavasti olettaen,
että käytössä on verkon vieruslistaesitys:

\begin{code}
keko.push({0,alku})
while not keko.empty()
    solmu = keko.pop()
    if (kasitelty[solmu.id])
        continue
    kasitelty[solmu.id] = true
    for kaari in verkko[solmu]
        nyky = etaisyys[kaari.loppu]
        uusi = etaisyys[solmu]+kaari.paino
        if uusi < nyky
            etaisyys[kaari.loppu] = uusi
            keko.push({uusi,kaari.loppu})
\end{code}

Huomaa, että keossa voi olla samaan aikaan \emph{useita} etäisyyksiä
samalle solmulle, koska lisäämme kekoon uuden solmun
aina etäisyyden parantuessa.
Käsittelemme kuitenkin jokaisen solmun vain kerran,
koska aina kun olemme hakeneet uuden solmun keosta käsittelyä varten,
varmistamme ensin, että emme ole käsitelleet sitä aiemmin.

Dijkstran algoritmi on ahne algoritmi,
koska se valitsee joka vaiheessa käsittelyyn solmun,
jonka etäisyys on pienin, minkä jälkeen kyseisen
solmun etäisyys ei einää muutu.
Miten voimme olla varmoja, että olemme löytäneet
tässä vaiheessa oikean etäisyyden?

Voimme ajatella asiaa siltä kannalta,
että jos etäisyyttä olisi mahdollista parantaa,
niin verkossa olisi oltava jokin toinen vielä
käsittelemätön solmu, jonka kautta voisimme muodostaa lyhemmän polun.
Kuitenkin tiedämme, että kaikkien muiden tarjolla olevien solmujen
etäisyydet ovat suurempia tai yhtä suuria eivätkä etäisyydet voi lyhentyä,
koska verkossa ei ole negatiivisia kaaria.
Tästä syystä voimme turvallisesti valita käsittelyyn pienimmän etäisyyden
solmun ja kiinnittää sen etäisyyden.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\node[draw, circle] (1) at (0,1) {$1$};
\node[draw, circle] (2) at (2.5,2.5) {$2$};
\node[draw, circle] (3) at (2.5,-0.5) {$3$};
\node[draw, circle] (4) at (5,1) {$4$};

\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=below:9] {} (3);
\path[draw,thick,->] (2) -- node[font=\small,label=above:3] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=below:$-4$] {} (4);
\end{tikzpicture}
\end{center}
\caption{Dijkstran algoritmi ei toimi oikein negatiivisen kaaren takia.}
\label{fig:dijneg}
\end{figure}

Dijkstran algoritmi toimii siis oikein,
jos verkossa ei ole negatiivisia kaaria,
mutta kuinka nopeasti algoritmi toimii?
Algoritmi käy läpi verkon solmut
ja kaaret, missä kuluu aikaa $O(n+m)$.
Lisäksi algoritmissa on joukko kekoon liittyviä operaatioita,
jotka vaikuttavat tehokkuuteen.
Pahimmassa tapauksessa lisäämme jokaisen kaaren kohdalla
kekoon uuden alkion, eli lisäykset kekoon vievät aikaa $O(m \log m)$.
Toisaalta poistamme kaikki alkiot aikanaan keosta,
mihin menee myös aikaa $O(m \log m)$.
Algoritmin kokonaisaikavaativuus on siis $O(n + m \log m)$.

Voimme vielä hieman siistiä aikavaativuutta, kun oletamme,
että verkossa ei ole kahta kaarta, joiden alku- ja loppusolmu on sama.
Tällöin $m \le n^2$, jolloin $\log m = \log (n^2) = 2 \log n$
eli aikavaativuudeksi tulee $O(n+m \log n)$.
Lisäksi jos oletamme, että pääsemme lähtösolmusta kaikkiin solmuihin,
niin $n=O(m)$ ja aikavaativuus on yksinkertaisesti $O(m \log n)$.

Entä mitä tapahtuu, jos verkossa on kuitenkin negatiivinen kaari?
Tällöin Dijkstran algoritmi ei toimi välttämättä oikein.
Kuva \ref{fig:dijneg} näyttää esimerkin tällaisesta tilanteesta.
Algoritmi seuraa ahneesti ylempää polkua ja toteaa,
että pienin etäisyys solmusta 1 solmuun 4 on 8.
Kuitenkin parempi tapa olisi kulkea alempaa polkua,
jolloin polun pituus on vain 5.

\section{Kaikki lyhimmät polut}

Tarkastellaan sitten tilannetta, jossa haluamme etsiä
lyhimmät polut verkon \emph{kaikista} solmuista
\emph{kaikkiin} solmuihin.
Yksi mahdollisuus ratkaista tehtävä olisi suorittaa Bellman–Fordin algoritmi
tai Dijkstran algoritmi jokaisesta verkon solmusta alkaen.
Voimme kuitenkin ratkaista tehtävän suoremmin
etsimällä kaikki polut \emph{samanaikaisesti}
Floyd–Warshallin algoritmilla.

\subsection{Floyd–Warshallin algoritmi}

Floyd-Warshallin algoritmi muodostaa verkolle \emph{etäisyysmatriisin},
jossa rivin $a$ sarakkeessa $b$ on lyhimmän polun pituus
solmusta $a$ solmuun $b$.
Algoritmi alustaa ensin etäisyysmatriisin niin,
että siihen on merkitty vain etäisyydet,
jotka toteutuvat kulkemalla yksittäistä kaarta,
ja kaikissa muissa matriisin kohdissa etäisyys on ääretön.
Sitten algoritmi suorittaa $n$ kierrosta,
jotka on numeroitu $1,2,\dots,n$.
Kierroksella $k$ algoritmi etsii polkuja, joissa on välisolmuna
solmu $k$ sekä mahdollisesti solmuja $1,2,\dots,k-1$.
Jos tällainen polku parantaa etäisyyttä,
päivitämme uuden etäisyyden matriisiin.
Viimeisen kierroksen jälkeen jokainen solmu on ollut
välisolmuna poluilla, jolloin olemme saaneet selville
kaikki lyhimmät polut.

\begin{figure}
\center
\begin{center}
\begin{tikzpicture}[scale=0.6,label distance=-1.5mm]
\small
\newcommand\verkko[5]{
\begin{scope}[xshift=0.75cm,yshift=2cm]
\node[draw, circle, fill=#2] (1) at (0,0) {$1$};
\node[draw, circle, fill=#3] (2) at (2.5,0) {$2$};
\node[draw, circle, fill=#4] (3) at (0,-2.5) {$3$};
\node[draw, circle, fill=#5] (4) at (2.5,-2.5) {$4$};
\path[draw,thick,->] (1) -- node[font=\small,label=above:5] {} (2);
\path[draw,thick,->] (1) -- node[font=\small,label=left:1] {} (3);
\path[draw,thick,->] (2) -- node[font=\small,label=right:3] {} (4);
\path[draw,thick,->] (3) -- node[font=\small,label=above:2] {} (2);
\path[draw,thick,->] (4) -- node[font=\small,label=below:4] {} (3);
\end{scope}

\foreach \x in {1,2,3,4} \node at (-0.5,-2.5-\x) {\x};
\foreach \x in {1,2,3,4} \node at (-0.5+\x,-2.5) {\x};
\draw (0,-3) grid (4,-7);

\node at (2,-8) {kierros #1};
}
\begin{scope}
\verkko{1}{lightgray}{white}{white}{white}
\foreach \x/\v in {1/\infty,2/5,3/1,4/\infty} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/\infty} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/4,4/\infty} \node at (-0.5+\x,-6.5) {$\v$};
\end{scope}
\begin{scope}[xshift=5.5cm]
\verkko{2}{white}{lightgray}{white}{white}
\foreach \x/\v in {1/\infty,2/5,3/1,4/} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/4,4/\infty} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (3.5,-3.5) {$8$};
\node[color=red] at (3.5,-5.5) {$5$};
\end{scope}
\begin{scope}[xshift=11cm]
\verkko{3}{white}{white}{lightgray}{white}
\foreach \x/\v in {1/\infty,2/,3/1,4/8} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/\infty,3/\infty,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/\infty,4/5} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/,3/4,4/} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (1.5,-3.5) {$3$};
\node[color=red] at (1.5,-6.5) {$6$};
\node[color=red] at (3.5,-6.5) {$9$};
\end{scope}
\begin{scope}[xshift=16.5cm]
\verkko{4}{white}{white}{white}{lightgray}
\foreach \x/\v in {1/\infty,2/3,3/1,4/8} \node at (-0.5+\x,-3.5) {$\v$};
\foreach \x/\v in {1/\infty,2/,3/,4/3} \node at (-0.5+\x,-4.5) {$\v$};
\foreach \x/\v in {1/\infty,2/2,3/,4/5} \node at (-0.5+\x,-5.5) {$\v$};
\foreach \x/\v in {1/\infty,2/6,3/4,4/9} \node at (-0.5+\x,-6.5) {$\v$};
\node[color=red] at (1.5,-4.5) {$9$};
\node[color=red] at (2.5,-4.5) {$7$};
\node[color=red] at (2.5,-5.5) {$9$};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{Esimerkki Floyd–Warshallin algoritmin toiminnasta.}
\label{fig:flowar}
\end{figure}

Kuva \ref{fig:flowar} näyttää esimerkin Floyd–Warshallin algoritmin toiminnasta.
Kierroksella 1 etsimme polkuja, joissa solmu 1 on välisolmuna.
Tällaisia polkuja ei ole, koska solmuun 1 ei pääse mistään solmusta,
joten matriisi ei muutu.
Kierroksella 2 huomaamme, että voimme kulkea solmun 2 kautta
solmusta 1 solmuun 4, jolloin saamme etäisyyden 8.
Samoin voimme kulkea solmun 2 kautta solmusta 3 solmuun 4,
jolloin saamme etäisyyden 5.
Jatkamme vastaavasti, kunnes kierroksen 4 jälkeen olemme
saaneet selville kaikki etäisyydet ja etäisyysmatriisi on lopullinen.

Floyd–Warshallin algoritmin mukavana puolena on,
että se on hyvin helppoa toteuttaa.
Meidän riittää luoda kolme sisäkkäistä for-silmukkaa,
jotka toteuttavat matriisin päivitykset.
Seuraavassa koodissa muuttuja $k$ kertoo,
mikä kierros on kyseessä eli mitä solmua käytämme välisolmuna.
Jokaisella kierroksella käymme läpi kaikki solmuparit $(i,j)$
ja koetamme parantaa niiden etäisyyksiä kulkemalla solmun $k$ kautta.

\begin{code}
for k = 1 to n
    for i = 1 to n
        for j = 1 to n
            etaisyys[i][j] = min(etaisyys[i][j],
                                   etaisyys[i][k]+etaisyys[k][j])
\end{code}

Algoritmin aikavaativuus on selkeästi $O(n^3)$,
koska se muodostuu kolmesta sisäkkäisestä for-silmukasta.
Mutta miksi algoritmi onnistuu määrittämään kaikki etäisyydet?
Yksi tapa ymmärtää algoritmia on
ajatella algoritmin toimintaa ''käänteisesti'' rekursiivisesti:
kun verkossa on lyhin polku solmusta $a$ solmuun $b$,
millainen tämä polku voi olla?

Jos solmu $x$ kuuluu polkuun, meille syntyy kaksi osaongelmaa:
meidän tulee etsiä ensin lyhin polku solmusta $a$ solmuun $x$
ja sitten lyhin polku solmusta $x$ solmuun $b$.
Näiden polkujen muodostamisessa voimme jälleen käydä läpi tapauksia,
mitkä solmut kuuluvat polkuihin.
Esimerkiksi lyhin polku solmusta $a$ solmuun $x$
voi kulkea vuorostaan solmun $y$ kautta,
jolloin haluamme etsiä lyhimmät polut solmusta $a$ solmuun $y$
ja solmusta $y$ solmuun $x$, ja niin edelleen.

Floyd–Warshallin algoritmissa muodostamme joka vaiheessa
polkuja, joissa voi olla välisolmuina solmuja $1,2,\dots,i$.
Kun haluamme muodostaa lyhimmän polun solmusta $a$ solmuun $b$,
meillä on kaksi vaihtoehtoa:
Jos solmu $i$ on välisolmuna, yhdistämme lyhimmät polut
solmusta $a$ solmuun $i$ ja solmusta $i$ solmuun $b$.
Jos taas solmu $i$ ei ole välisolmuna, olemme käsitelleet
polun jo aiemmin.
Algoritmin päätteeksi välisolmuina voi olla solmuja $1,2,\dots,n$,
eli mikä tahansa verkon solmu voi olla välisolmu.

\subsection{Algoritmien vertailua}

Taulukko \ref{tab:reiver} näyttää yhteenvedon algoritmeista
lyhimpien polkujen etsimiseen.
Käytännössä leveyshaku ja Dijkstran algoritmi ovat
tavallisimmin käytettävät algoritmit:
jos kaarilla ei ole painoja, käytämme leveyshakua,
ja muuten Dijkstran algoritmia.
Dijkstran algoritmin rajoituksena on,
että verkossa ei saa olla negatiivisia kaaria,
mutta tämä ei yleensä ole ongelma käytännössä.
Esimerkiksi tien pituus ei voi olla negatiivinen
eikä lennon hinta voi olla negatiivinen.
Jos kuitenkin verkossa voi olla negatiivisia kaaria,
voimme turvautua Bellman–Fordin algoritmiin.

\begin{table}
\center
\begin{tabular}{lll}
algoritmi $n$ & aikavaativuus & erityistä \\
\hline
leveyshaku & $O(n+m)$ & ei salli painoja kaarissa \\
Bellman–Fordin algoritmi & $O(nm)$ & \\
Dijkstran algoritmi & $O(n+m \log n)$ & ei salli negatiivisia kaaria \\
Floyd–Warshallin algoritmi & $O(n^3)$ & etsii kaikki polut \\
\end{tabular}
\caption{Algoritmit lyhimpien polkujen etsimiseen.}
\label{tab:reiver}
\end{table}

Miten sitten Floyd–Warshallin algoritmi vertautuu muihin algoritmeihin?
Tämä riippuu siitä, onko verkko \emph{harva} vai \emph{tiheä}.
Harvassa verkossa on vähän kaaria ja $m \approx n$,
kun taas tiheässä verkossa on paljon kaaria ja $m \approx n^2$.
Floyd–Warshallin algoritmi on parhaimmillaan silloin,
kun verkko on tiheä, koska sen aikavaativuus ei riipu
kaarten määrästä.
Esimerkiksi jos etsimme kaikki lyhimmät polut
suorittamalla $n$ kertaa Dijkstran algoritmin,
harvassa verkossa aikaa kuluu $O(n^2 \log n)$,
mutta tiheässä verkossa aikaa kuluu $O(n^3 \log n)$.
Siis harvassa verkossa aikavaativuus on parempi
kuin Floyd–Warshallin algoritmissa,
mutta tiheässä verkossa se on huonompi.
Toisaalta Floyd–Warshallin algoritmin vakiokertoimet
ovat hyvin pienet sen yksinkertaisen rakenteen ansiosta.